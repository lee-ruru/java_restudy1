!SESSION 2022-04-22 08:08:45.395 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=11.0.14.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\java_restudy1\.metadata\.bak_0.log
Created Time: 2022-04-22 08:12:22.154

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-22 08:12:22.154
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-22 08:12:22.198
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-22 08:12:22.228
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day1;

public class java1 {

	public static void main(String[] args) {
		// 03-01 숫자 (Number)
		//정수
		//실수
		//8진수와 16진수
		//숫자연산
		//증감연산 (++, --)
		//숫자 자료형은 숫자 형태로 이루어진 자료형으로 우리가 이미 익숙히 알고 있는 것들이다. 
		//123과 같은 정수, 12.34 같은 실수, 드물게 쓰이긴 하지만 8진수나 16진수 같은 것들도 있다.

		//정수
		//자바의 정수를 표현하기 위한 자료형은 int, long 이다. (byte, short 등도 있지만 잘 사용하지 않는다.)
		//int와 long의 차이는 표현할 수 있는 숫자의 범위이다.
		//자료형	표현범위
		//int	-21474 ~ 2147483
		//long	-922337 ~ 92233720368

		//int age = 10;
		//long countOfStar = 876482738L;
		//long 변수에 값을 대입할 때는 대입하는 숫자 값이 int 자료형의 최대값인 214748 보다 큰 경우 87648273L과 같이 
		//L 접미사(또는 소문자 l, 소문자 'l'은 숫자 1과 비슷하게 보이므로 추천하지 않는다.)를 붙여 주어야 한다.
		//만약 큰 숫자에 'L'과 같은 접미사를 누락하면 컴파일 에러가 발생한다.

		//실수
		//자바의 실수를 표현하기 위한 자료형은 float, double 이다
		//float와 double의 차이 역시 표현할 수 있는 숫자의 범위이다.
		//자료형	표현범위
		//float	 ~ 
		//double	 ~ 

		//float pi = 3.14F;
		//double morePi = 3.1415926;
		//자바에서 실수형은 디폴트가 double이므로 위의 예에서 보듯이 float 변수에 값을 대입할 때에는 3.14F 와 같이 
		//F접미사(또는 소문자 f)를 꼭 붙여 주어야 한다. 
		//float 자료형에 값을 대입할 때 접미사를 누락하면 컴파일 에러가 발생한다.
		//또는 과학적 지수 표현식으로 다음과 같이 사용할 수 있다.

		double d1 = 123.4;
		double d2 = 1.234e2;
		d1과 d2의 값은 123.4로 같다. d2의 e2는 10의 제곱()을 의미한다. 즉  이 되어 123.4 가 되는 것이다.

		8진수와 16진수
		8진수와 16진수는 int 자료형을 사용하여 표시한다.

		0(숫자 '0')으로 시작하면 8진수, 0x(숫자 '0' + 알파벳 'x')로 시작하면 16진수가 된다.

		tip
		8진수와 16진수

		8진수
		16진수
		다음과 같이 사용된다.

		int octal = 023;    // 십진수: 19
		int hex = 0xC;     // 십진수: 12
		023과 0xC에 해당되는 십진수 값은 각각 19, 12이다.

		숫자연산
		자바의 사칙연산은 실생활에서 일반적으로 사용하는 사칙연산과 다를 바가 없다. 자바는 +, -, *, / 기호를 이용하여 두 숫자간 사칙연산을 수행한다.

		다음과 같이 사칙연산을 수행하는 자바 프로그램을 작성 해 보자.

		Samplejava

		public class Sample {
		    public static void main(String[] args) {
		        int a = 10;
		        int b = 5;
		        System.out.println(a+b);
		        System.out.println(a-b);
		        System.out.println(a*b);
		        System.out.println(a/b);
		    }
		}
		프로그램 작성 후 실행해 보면 다음과 같이 출력된다.

		15
		5
		50
		2
		프로그래밍을 접해 본 적이 없는 독자라면 %연산자는 본 적이 없을 것이다. %는 나머지 값을 반환하는 연산자이다. 7을 3으로 나누면 나머지는 1이 될 것이고 3을 7로 나누면 나머지는 3이 될 것이다.

		다음의 예로 확인해 보자.

		public class Sample {
		    public static void main(String[] args) {
		        System.out.println(7 % 3);  // 1 출력
		        System.out.println(3 % 7);  // 3 출력
		    }
		}
		tip
		[중요] Sample.java

		앞으로 이 책에서 설명하는 모든 예제는 Sample.java 파일내에 구현하여 실행할 것이다. 만약 이 책의 예제 중 Sample 클래스 없이 수행문장만 있을 경우에는 Sample 클래스의 main 메소드 안에 해당 문장을 작성하여 실행하도록 하자.

		만약 책에 다음과 같이 수행문장만 있는 예제가 있다면,

		System.out.println(7 % 3);  // 1 출력
		System.out.println(3 % 7);  // 3 출력
		다음처럼 Sample 클래스의 main 메소드에 수행할 문장을 작성한 후 실행하자.

		public class Sample {
		    public static void main(String[] args) {
		        System.out.println(7 % 3);  // 1 출력
		        System.out.println(3 % 7);  // 3 출력
		    }
		}
		증감연산 (++, --)
		자바는 ++, -- 기호를 이용하여 값을 증가하거나 감소시킬 수 있다. 이러한 ++, -- 기호를 증감 연산자라고도 한다.

		다음의 예를 보자.

		int i = 0;
		int j = 10;
		i++;
		j--;

		System.out.println(i);  // 1 출력
		System.out.println(j);  // 9 출력
		++는 값을 1만큼 증가시키고 --는 값을 1만큼 감소시킨다는 것을 확인 할 수 있다. 하지만 여기서 잠깐 실수하기 쉬운 것이 있다. 그것은 바로 ++, -- 등의 연산자의 위치이다.

		다음의 예제를 보자.

		int i = 0;
		System.out.println(i++);  // 0 출력
		System.out.println(i);  // 1 출력
		System.out.println(i++) 의 출력값은 i가 1만큼 증가되어 1 이 출력되어야 할 것 같지만 0 이 출력되었다. 그렇다면 변수 i의 값이 증가되지 않은것일까? 그 다음 문장인 System.out.println(i) 의 출력값을 확인 해 보니 1이 나온다.

		그렇다면 i의 값은 증가된 것이다.

		이런 결과가 나오는 원인은 변수 ++ 연산자의 위치 때문이다. 즉 i++ 와 같이 ++ 연산자가 변수명 뒤에 붙으면 해당 코드가 실행되는 순간에는 i 값이 변경되지 않는다. 다만 i++ 문장이 실행된 이후에 i값이 증가하게 된다. 이와는 반대로 i++ 대신 ++i라고 사용하게 되면 i 값이 먼저 증가된 후에 해당 코드가 실행된다.

		즉, 다음과 같은 차이가 있으니 잊지 말도록 하자.

		i++ : 값이 참조된 후에 증가
		++i : 값이 참조되기 전에 증가
		다음처럼 연산자의 위치를 변경하여 확인 해 보자.

		int i = 0;
		System.out.println(++i);  // 1 출력
		System.out.println(i);  // 1 출력
		++i 에 의해서 i값이 참조되기 전에 증가된 것을 확인 할 수 있다.

		-- 연산자도 ++ 연산자와 동일한 규칙을 따른다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-22 08:12:22.229
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-22 08:12:22.230
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-22 08:12:24.725
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day1;

public class java1 {

	public static void main(String[] args) {
		// 03-01 숫자 (Number)
		//정수
		//실수
		//8진수와 16진수
		//숫자연산
		//증감연산 (++, --)
		//숫자 자료형은 숫자 형태로 이루어진 자료형으로 우리가 이미 익숙히 알고 있는 것들이다. 
		//123과 같은 정수, 12.34 같은 실수, 드물게 쓰이긴 하지만 8진수나 16진수 같은 것들도 있다.

		//정수
		//자바의 정수를 표현하기 위한 자료형은 int, long 이다. (byte, short 등도 있지만 잘 사용하지 않는다.)
		//int와 long의 차이는 표현할 수 있는 숫자의 범위이다.
		//자료형	표현범위
		//int	-21474 ~ 2147483
		//long	-922337 ~ 92233720368

		//int age = 10;
		//long countOfStar = 876482738L;
		//long 변수에 값을 대입할 때는 대입하는 숫자 값이 int 자료형의 최대값인 214748 보다 큰 경우 87648273L과 같이 
		//L 접미사(또는 소문자 l, 소문자 'l'은 숫자 1과 비슷하게 보이므로 추천하지 않는다.)를 붙여 주어야 한다.
		//만약 큰 숫자에 'L'과 같은 접미사를 누락하면 컴파일 에러가 발생한다.

		//실수
		//자바의 실수를 표현하기 위한 자료형은 float, double 이다
		//float와 double의 차이 역시 표현할 수 있는 숫자의 범위이다.
		//자료형	표현범위
		//float	 ~ 
		//double	 ~ 

		//float pi = 3.14F;
		//double morePi = 3.1415926;
		//자바에서 실수형은 디폴트가 double이므로 위의 예에서 보듯이 float 변수에 값을 대입할 때에는 3.14F 와 같이 
		//F접미사(또는 소문자 f)를 꼭 붙여 주어야 한다. 
		//float 자료형에 값을 대입할 때 접미사를 누락하면 컴파일 에러가 발생한다.
		//또는 과학적 지수 표현식으로 다음과 같이 사용할 수 있다.

		//double d1 = 123.4;
		//double d2 = 1.234e2;
		d1과 d2의 값은 123.4로 같다. d2의 e2는 10의 제곱()을 의미한다. 즉  이 되어 123.4 가 되는 것이다.

		8진수와 16진수
		8진수와 16진수는 int 자료형을 사용하여 표시한다.

		0(숫자 '0')으로 시작하면 8진수, 0x(숫자 '0' + 알파벳 'x')로 시작하면 16진수가 된다.

		tip
		8진수와 16진수

		8진수
		16진수
		다음과 같이 사용된다.

		int octal = 023;    // 십진수: 19
		int hex = 0xC;     // 십진수: 12
		023과 0xC에 해당되는 십진수 값은 각각 19, 12이다.

		숫자연산
		자바의 사칙연산은 실생활에서 일반적으로 사용하는 사칙연산과 다를 바가 없다. 자바는 +, -, *, / 기호를 이용하여 두 숫자간 사칙연산을 수행한다.

		다음과 같이 사칙연산을 수행하는 자바 프로그램을 작성 해 보자.

		Samplejava

		public class Sample {
		    public static void main(String[] args) {
		        int a = 10;
		        int b = 5;
		        System.out.println(a+b);
		        System.out.println(a-b);
		        System.out.println(a*b);
		        System.out.println(a/b);
		    }
		}
		프로그램 작성 후 실행해 보면 다음과 같이 출력된다.

		15
		5
		50
		2
		프로그래밍을 접해 본 적이 없는 독자라면 %연산자는 본 적이 없을 것이다. %는 나머지 값을 반환하는 연산자이다. 7을 3으로 나누면 나머지는 1이 될 것이고 3을 7로 나누면 나머지는 3이 될 것이다.

		다음의 예로 확인해 보자.

		public class Sample {
		    public static void main(String[] args) {
		        System.out.println(7 % 3);  // 1 출력
		        System.out.println(3 % 7);  // 3 출력
		    }
		}
		tip
		[중요] Sample.java

		앞으로 이 책에서 설명하는 모든 예제는 Sample.java 파일내에 구현하여 실행할 것이다. 만약 이 책의 예제 중 Sample 클래스 없이 수행문장만 있을 경우에는 Sample 클래스의 main 메소드 안에 해당 문장을 작성하여 실행하도록 하자.

		만약 책에 다음과 같이 수행문장만 있는 예제가 있다면,

		System.out.println(7 % 3);  // 1 출력
		System.out.println(3 % 7);  // 3 출력
		다음처럼 Sample 클래스의 main 메소드에 수행할 문장을 작성한 후 실행하자.

		public class Sample {
		    public static void main(String[] args) {
		        System.out.println(7 % 3);  // 1 출력
		        System.out.println(3 % 7);  // 3 출력
		    }
		}
		증감연산 (++, --)
		자바는 ++, -- 기호를 이용하여 값을 증가하거나 감소시킬 수 있다. 이러한 ++, -- 기호를 증감 연산자라고도 한다.

		다음의 예를 보자.

		int i = 0;
		int j = 10;
		i++;
		j--;

		System.out.println(i);  // 1 출력
		System.out.println(j);  // 9 출력
		++는 값을 1만큼 증가시키고 --는 값을 1만큼 감소시킨다는 것을 확인 할 수 있다. 하지만 여기서 잠깐 실수하기 쉬운 것이 있다. 그것은 바로 ++, -- 등의 연산자의 위치이다.

		다음의 예제를 보자.

		int i = 0;
		System.out.println(i++);  // 0 출력
		System.out.println(i);  // 1 출력
		System.out.println(i++) 의 출력값은 i가 1만큼 증가되어 1 이 출력되어야 할 것 같지만 0 이 출력되었다. 그렇다면 변수 i의 값이 증가되지 않은것일까? 그 다음 문장인 System.out.println(i) 의 출력값을 확인 해 보니 1이 나온다.

		그렇다면 i의 값은 증가된 것이다.

		이런 결과가 나오는 원인은 변수 ++ 연산자의 위치 때문이다. 즉 i++ 와 같이 ++ 연산자가 변수명 뒤에 붙으면 해당 코드가 실행되는 순간에는 i 값이 변경되지 않는다. 다만 i++ 문장이 실행된 이후에 i값이 증가하게 된다. 이와는 반대로 i++ 대신 ++i라고 사용하게 되면 i 값이 먼저 증가된 후에 해당 코드가 실행된다.

		즉, 다음과 같은 차이가 있으니 잊지 말도록 하자.

		i++ : 값이 참조된 후에 증가
		++i : 값이 참조되기 전에 증가
		다음처럼 연산자의 위치를 변경하여 확인 해 보자.

		int i = 0;
		System.out.println(++i);  // 1 출력
		System.out.println(i);  // 1 출력
		++i 에 의해서 i값이 참조되기 전에 증가된 것을 확인 할 수 있다.

		-- 연산자도 ++ 연산자와 동일한 규칙을 따른다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-22 08:12:24.726
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-22 08:12:24.727
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-22 08:12:24.755
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day1;

public class java1 {

	public static void main(String[] args) {
		// 03-01 숫자 (Number)
		//정수
		//실수
		//8진수와 16진수
		//숫자연산
		//증감연산 (++, --)
		//숫자 자료형은 숫자 형태로 이루어진 자료형으로 우리가 이미 익숙히 알고 있는 것들이다. 
		//123과 같은 정수, 12.34 같은 실수, 드물게 쓰이긴 하지만 8진수나 16진수 같은 것들도 있다.

		//정수
		//자바의 정수를 표현하기 위한 자료형은 int, long 이다. (byte, short 등도 있지만 잘 사용하지 않는다.)
		//int와 long의 차이는 표현할 수 있는 숫자의 범위이다.
		//자료형	표현범위
		//int	-21474 ~ 2147483
		//long	-922337 ~ 92233720368

		//int age = 10;
		//long countOfStar = 876482738L;
		//long 변수에 값을 대입할 때는 대입하는 숫자 값이 int 자료형의 최대값인 214748 보다 큰 경우 87648273L과 같이 
		//L 접미사(또는 소문자 l, 소문자 'l'은 숫자 1과 비슷하게 보이므로 추천하지 않는다.)를 붙여 주어야 한다.
		//만약 큰 숫자에 'L'과 같은 접미사를 누락하면 컴파일 에러가 발생한다.

		//실수
		//자바의 실수를 표현하기 위한 자료형은 float, double 이다
		//float와 double의 차이 역시 표현할 수 있는 숫자의 범위이다.
		//자료형	표현범위
		//float	 ~ 
		//double	 ~ 

		//float pi = 3.14F;
		//double morePi = 3.1415926;
		//자바에서 실수형은 디폴트가 double이므로 위의 예에서 보듯이 float 변수에 값을 대입할 때에는 3.14F 와 같이 
		//F접미사(또는 소문자 f)를 꼭 붙여 주어야 한다. 
		//float 자료형에 값을 대입할 때 접미사를 누락하면 컴파일 에러가 발생한다.
		//또는 과학적 지수 표현식으로 다음과 같이 사용할 수 있다.

		//double d1 = 123.4;
		//double d2 = 1.234e2;
		d1과 d2의 값은 123.4로 같다. d2의 e2는 10의 제곱()을 의미한다. 즉  이 되어 123.4 가 되는 것이다.

		8진수와 16진수
		8진수와 16진수는 int 자료형을 사용하여 표시한다.

		0(숫자 '0')으로 시작하면 8진수, 0x(숫자 '0' + 알파벳 'x')로 시작하면 16진수가 된다.

		tip
		8진수와 16진수

		8진수
		16진수
		다음과 같이 사용된다.

		int octal = 023;    // 십진수: 19
		int hex = 0xC;     // 십진수: 12
		023과 0xC에 해당되는 십진수 값은 각각 19, 12이다.

		숫자연산
		자바의 사칙연산은 실생활에서 일반적으로 사용하는 사칙연산과 다를 바가 없다. 자바는 +, -, *, / 기호를 이용하여 두 숫자간 사칙연산을 수행한다.

		다음과 같이 사칙연산을 수행하는 자바 프로그램을 작성 해 보자.

		Samplejava

		public class Sample {
		    public static void main(String[] args) {
		        int a = 10;
		        int b = 5;
		        System.out.println(a+b);
		        System.out.println(a-b);
		        System.out.println(a*b);
		        System.out.println(a/b);
		    }
		}
		프로그램 작성 후 실행해 보면 다음과 같이 출력된다.

		15
		5
		50
		2
		프로그래밍을 접해 본 적이 없는 독자라면 %연산자는 본 적이 없을 것이다. %는 나머지 값을 반환하는 연산자이다. 7을 3으로 나누면 나머지는 1이 될 것이고 3을 7로 나누면 나머지는 3이 될 것이다.

		다음의 예로 확인해 보자.

		public class Sample {
		    public static void main(String[] args) {
		        System.out.println(7 % 3);  // 1 출력
		        System.out.println(3 % 7);  // 3 출력
		    }
		}
		tip
		[중요] Sample.java

		앞으로 이 책에서 설명하는 모든 예제는 Sample.java 파일내에 구현하여 실행할 것이다. 만약 이 책의 예제 중 Sample 클래스 없이 수행문장만 있을 경우에는 Sample 클래스의 main 메소드 안에 해당 문장을 작성하여 실행하도록 하자.

		만약 책에 다음과 같이 수행문장만 있는 예제가 있다면,

		System.out.println(7 % 3);  // 1 출력
		System.out.println(3 % 7);  // 3 출력
		다음처럼 Sample 클래스의 main 메소드에 수행할 문장을 작성한 후 실행하자.

		public class Sample {
		    public static void main(String[] args) {
		        System.out.println(7 % 3);  // 1 출력
		        System.out.println(3 % 7);  // 3 출력
		    }
		}
		증감연산 (++, --)
		자바는 ++, -- 기호를 이용하여 값을 증가하거나 감소시킬 수 있다. 이러한 ++, -- 기호를 증감 연산자라고도 한다.

		다음의 예를 보자.

		int i = 0;
		int j = 10;
		i++;
		j--;

		System.out.println(i);  // 1 출력
		System.out.println(j);  // 9 출력
		++는 값을 1만큼 증가시키고 --는 값을 1만큼 감소시킨다는 것을 확인 할 수 있다. 하지만 여기서 잠깐 실수하기 쉬운 것이 있다. 그것은 바로 ++, -- 등의 연산자의 위치이다.

		다음의 예제를 보자.

		int i = 0;
		System.out.println(i++);  // 0 출력
		System.out.println(i);  // 1 출력
		System.out.println(i++) 의 출력값은 i가 1만큼 증가되어 1 이 출력되어야 할 것 같지만 0 이 출력되었다. 그렇다면 변수 i의 값이 증가되지 않은것일까? 그 다음 문장인 System.out.println(i) 의 출력값을 확인 해 보니 1이 나온다.

		그렇다면 i의 값은 증가된 것이다.

		이런 결과가 나오는 원인은 변수 ++ 연산자의 위치 때문이다. 즉 i++ 와 같이 ++ 연산자가 변수명 뒤에 붙으면 해당 코드가 실행되는 순간에는 i 값이 변경되지 않는다. 다만 i++ 문장이 실행된 이후에 i값이 증가하게 된다. 이와는 반대로 i++ 대신 ++i라고 사용하게 되면 i 값이 먼저 증가된 후에 해당 코드가 실행된다.

		즉, 다음과 같은 차이가 있으니 잊지 말도록 하자.

		i++ : 값이 참조된 후에 증가
		++i : 값이 참조되기 전에 증가
		다음처럼 연산자의 위치를 변경하여 확인 해 보자.

		int i = 0;
		System.out.println(++i);  // 1 출력
		System.out.println(i);  // 1 출력
		++i 에 의해서 i값이 참조되기 전에 증가된 것을 확인 할 수 있다.

		-- 연산자도 ++ 연산자와 동일한 규칙을 따른다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-22 08:12:24.756
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-22 08:12:24.757
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-22 08:12:27.753
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day1;

public class java1 {

	public static void main(String[] args) {
		// 03-01 숫자 (Number)
		//정수
		//실수
		//8진수와 16진수
		//숫자연산
		//증감연산 (++, --)
		//숫자 자료형은 숫자 형태로 이루어진 자료형으로 우리가 이미 익숙히 알고 있는 것들이다. 
		//123과 같은 정수, 12.34 같은 실수, 드물게 쓰이긴 하지만 8진수나 16진수 같은 것들도 있다.

		//정수
		//자바의 정수를 표현하기 위한 자료형은 int, long 이다. (byte, short 등도 있지만 잘 사용하지 않는다.)
		//int와 long의 차이는 표현할 수 있는 숫자의 범위이다.
		//자료형	표현범위
		//int	-21474 ~ 2147483
		//long	-922337 ~ 92233720368

		//int age = 10;
		//long countOfStar = 876482738L;
		//long 변수에 값을 대입할 때는 대입하는 숫자 값이 int 자료형의 최대값인 214748 보다 큰 경우 87648273L과 같이 
		//L 접미사(또는 소문자 l, 소문자 'l'은 숫자 1과 비슷하게 보이므로 추천하지 않는다.)를 붙여 주어야 한다.
		//만약 큰 숫자에 'L'과 같은 접미사를 누락하면 컴파일 에러가 발생한다.

		//실수
		//자바의 실수를 표현하기 위한 자료형은 float, double 이다
		//float와 double의 차이 역시 표현할 수 있는 숫자의 범위이다.
		//자료형	표현범위
		//float	 ~ 
		//double	 ~ 

		//float pi = 3.14F;
		//double morePi = 3.1415926;
		//자바에서 실수형은 디폴트가 double이므로 위의 예에서 보듯이 float 변수에 값을 대입할 때에는 3.14F 와 같이 
		//F접미사(또는 소문자 f)를 꼭 붙여 주어야 한다. 
		//float 자료형에 값을 대입할 때 접미사를 누락하면 컴파일 에러가 발생한다.
		//또는 과학적 지수 표현식으로 다음과 같이 사용할 수 있다.

		//double d1 = 123.4;
		//double d2 = 1.234e2;
		//d1과 d2의 값은 123.4로 같다. d2의 e2는 10의 제곱()을 의미한다. 즉  이 되어 123.4 가 되는 것이다.

		8진수와 16진수
		8진수와 16진수는 int 자료형을 사용하여 표시한다.

		0(숫자 '0')으로 시작하면 8진수, 0x(숫자 '0' + 알파벳 'x')로 시작하면 16진수가 된다.

		tip
		8진수와 16진수

		8진수
		16진수
		다음과 같이 사용된다.

		int octal = 023;    // 십진수: 19
		int hex = 0xC;     // 십진수: 12
		023과 0xC에 해당되는 십진수 값은 각각 19, 12이다.

		숫자연산
		자바의 사칙연산은 실생활에서 일반적으로 사용하는 사칙연산과 다를 바가 없다. 자바는 +, -, *, / 기호를 이용하여 두 숫자간 사칙연산을 수행한다.

		다음과 같이 사칙연산을 수행하는 자바 프로그램을 작성 해 보자.

		Samplejava

		public class Sample {
		    public static void main(String[] args) {
		        int a = 10;
		        int b = 5;
		        System.out.println(a+b);
		        System.out.println(a-b);
		        System.out.println(a*b);
		        System.out.println(a/b);
		    }
		}
		프로그램 작성 후 실행해 보면 다음과 같이 출력된다.

		15
		5
		50
		2
		프로그래밍을 접해 본 적이 없는 독자라면 %연산자는 본 적이 없을 것이다. %는 나머지 값을 반환하는 연산자이다. 7을 3으로 나누면 나머지는 1이 될 것이고 3을 7로 나누면 나머지는 3이 될 것이다.

		다음의 예로 확인해 보자.

		public class Sample {
		    public static void main(String[] args) {
		        System.out.println(7 % 3);  // 1 출력
		        System.out.println(3 % 7);  // 3 출력
		    }
		}
		tip
		[중요] Sample.java

		앞으로 이 책에서 설명하는 모든 예제는 Sample.java 파일내에 구현하여 실행할 것이다. 만약 이 책의 예제 중 Sample 클래스 없이 수행문장만 있을 경우에는 Sample 클래스의 main 메소드 안에 해당 문장을 작성하여 실행하도록 하자.

		만약 책에 다음과 같이 수행문장만 있는 예제가 있다면,

		System.out.println(7 % 3);  // 1 출력
		System.out.println(3 % 7);  // 3 출력
		다음처럼 Sample 클래스의 main 메소드에 수행할 문장을 작성한 후 실행하자.

		public class Sample {
		    public static void main(String[] args) {
		        System.out.println(7 % 3);  // 1 출력
		        System.out.println(3 % 7);  // 3 출력
		    }
		}
		증감연산 (++, --)
		자바는 ++, -- 기호를 이용하여 값을 증가하거나 감소시킬 수 있다. 이러한 ++, -- 기호를 증감 연산자라고도 한다.

		다음의 예를 보자.

		int i = 0;
		int j = 10;
		i++;
		j--;

		System.out.println(i);  // 1 출력
		System.out.println(j);  // 9 출력
		++는 값을 1만큼 증가시키고 --는 값을 1만큼 감소시킨다는 것을 확인 할 수 있다. 하지만 여기서 잠깐 실수하기 쉬운 것이 있다. 그것은 바로 ++, -- 등의 연산자의 위치이다.

		다음의 예제를 보자.

		int i = 0;
		System.out.println(i++);  // 0 출력
		System.out.println(i);  // 1 출력
		System.out.println(i++) 의 출력값은 i가 1만큼 증가되어 1 이 출력되어야 할 것 같지만 0 이 출력되었다. 그렇다면 변수 i의 값이 증가되지 않은것일까? 그 다음 문장인 System.out.println(i) 의 출력값을 확인 해 보니 1이 나온다.

		그렇다면 i의 값은 증가된 것이다.

		이런 결과가 나오는 원인은 변수 ++ 연산자의 위치 때문이다. 즉 i++ 와 같이 ++ 연산자가 변수명 뒤에 붙으면 해당 코드가 실행되는 순간에는 i 값이 변경되지 않는다. 다만 i++ 문장이 실행된 이후에 i값이 증가하게 된다. 이와는 반대로 i++ 대신 ++i라고 사용하게 되면 i 값이 먼저 증가된 후에 해당 코드가 실행된다.

		즉, 다음과 같은 차이가 있으니 잊지 말도록 하자.

		i++ : 값이 참조된 후에 증가
		++i : 값이 참조되기 전에 증가
		다음처럼 연산자의 위치를 변경하여 확인 해 보자.

		int i = 0;
		System.out.println(++i);  // 1 출력
		System.out.println(i);  // 1 출력
		++i 에 의해서 i값이 참조되기 전에 증가된 것을 확인 할 수 있다.

		-- 연산자도 ++ 연산자와 동일한 규칙을 따른다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-22 08:12:27.797
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-22 08:12:27.798
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-22 08:12:27.821
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day1;

public class java1 {

	public static void main(String[] args) {
		// 03-01 숫자 (Number)
		//정수
		//실수
		//8진수와 16진수
		//숫자연산
		//증감연산 (++, --)
		//숫자 자료형은 숫자 형태로 이루어진 자료형으로 우리가 이미 익숙히 알고 있는 것들이다. 
		//123과 같은 정수, 12.34 같은 실수, 드물게 쓰이긴 하지만 8진수나 16진수 같은 것들도 있다.

		//정수
		//자바의 정수를 표현하기 위한 자료형은 int, long 이다. (byte, short 등도 있지만 잘 사용하지 않는다.)
		//int와 long의 차이는 표현할 수 있는 숫자의 범위이다.
		//자료형	표현범위
		//int	-21474 ~ 2147483
		//long	-922337 ~ 92233720368

		//int age = 10;
		//long countOfStar = 876482738L;
		//long 변수에 값을 대입할 때는 대입하는 숫자 값이 int 자료형의 최대값인 214748 보다 큰 경우 87648273L과 같이 
		//L 접미사(또는 소문자 l, 소문자 'l'은 숫자 1과 비슷하게 보이므로 추천하지 않는다.)를 붙여 주어야 한다.
		//만약 큰 숫자에 'L'과 같은 접미사를 누락하면 컴파일 에러가 발생한다.

		//실수
		//자바의 실수를 표현하기 위한 자료형은 float, double 이다
		//float와 double의 차이 역시 표현할 수 있는 숫자의 범위이다.
		//자료형	표현범위
		//float	 ~ 
		//double	 ~ 

		//float pi = 3.14F;
		//double morePi = 3.1415926;
		//자바에서 실수형은 디폴트가 double이므로 위의 예에서 보듯이 float 변수에 값을 대입할 때에는 3.14F 와 같이 
		//F접미사(또는 소문자 f)를 꼭 붙여 주어야 한다. 
		//float 자료형에 값을 대입할 때 접미사를 누락하면 컴파일 에러가 발생한다.
		//또는 과학적 지수 표현식으로 다음과 같이 사용할 수 있다.

		//double d1 = 123.4;
		//double d2 = 1.234e2;
		//d1과 d2의 값은 123.4로 같다. d2의 e2는 10의 제곱()을 의미한다. 즉  이 되어 123.4 가 되는 것이다.

		8진수와 16진수
		8진수와 16진수는 int 자료형을 사용하여 표시한다.

		0(숫자 '0')으로 시작하면 8진수, 0x(숫자 '0' + 알파벳 'x')로 시작하면 16진수가 된다.

		tip
		8진수와 16진수

		8진수
		16진수
		다음과 같이 사용된다.

		int octal = 023;    // 십진수: 19
		int hex = 0xC;     // 십진수: 12
		023과 0xC에 해당되는 십진수 값은 각각 19, 12이다.

		숫자연산
		자바의 사칙연산은 실생활에서 일반적으로 사용하는 사칙연산과 다를 바가 없다. 자바는 +, -, *, / 기호를 이용하여 두 숫자간 사칙연산을 수행한다.

		다음과 같이 사칙연산을 수행하는 자바 프로그램을 작성 해 보자.

		Samplejava

		public class Sample {
		    public static void main(String[] args) {
		        int a = 10;
		        int b = 5;
		        System.out.println(a+b);
		        System.out.println(a-b);
		        System.out.println(a*b);
		        System.out.println(a/b);
		    }
		}
		프로그램 작성 후 실행해 보면 다음과 같이 출력된다.

		15
		5
		50
		2
		프로그래밍을 접해 본 적이 없는 독자라면 %연산자는 본 적이 없을 것이다. %는 나머지 값을 반환하는 연산자이다. 7을 3으로 나누면 나머지는 1이 될 것이고 3을 7로 나누면 나머지는 3이 될 것이다.

		다음의 예로 확인해 보자.

		public class Sample {
		    public static void main(String[] args) {
		        System.out.println(7 % 3);  // 1 출력
		        System.out.println(3 % 7);  // 3 출력
		    }
		}
		tip
		[중요] Sample.java

		앞으로 이 책에서 설명하는 모든 예제는 Sample.java 파일내에 구현하여 실행할 것이다. 만약 이 책의 예제 중 Sample 클래스 없이 수행문장만 있을 경우에는 Sample 클래스의 main 메소드 안에 해당 문장을 작성하여 실행하도록 하자.

		만약 책에 다음과 같이 수행문장만 있는 예제가 있다면,

		System.out.println(7 % 3);  // 1 출력
		System.out.println(3 % 7);  // 3 출력
		다음처럼 Sample 클래스의 main 메소드에 수행할 문장을 작성한 후 실행하자.

		public class Sample {
		    public static void main(String[] args) {
		        System.out.println(7 % 3);  // 1 출력
		        System.out.println(3 % 7);  // 3 출력
		    }
		}
		증감연산 (++, --)
		자바는 ++, -- 기호를 이용하여 값을 증가하거나 감소시킬 수 있다. 이러한 ++, -- 기호를 증감 연산자라고도 한다.

		다음의 예를 보자.

		int i = 0;
		int j = 10;
		i++;
		j--;

		System.out.println(i);  // 1 출력
		System.out.println(j);  // 9 출력
		++는 값을 1만큼 증가시키고 --는 값을 1만큼 감소시킨다는 것을 확인 할 수 있다. 하지만 여기서 잠깐 실수하기 쉬운 것이 있다. 그것은 바로 ++, -- 등의 연산자의 위치이다.

		다음의 예제를 보자.

		int i = 0;
		System.out.println(i++);  // 0 출력
		System.out.println(i);  // 1 출력
		System.out.println(i++) 의 출력값은 i가 1만큼 증가되어 1 이 출력되어야 할 것 같지만 0 이 출력되었다. 그렇다면 변수 i의 값이 증가되지 않은것일까? 그 다음 문장인 System.out.println(i) 의 출력값을 확인 해 보니 1이 나온다.

		그렇다면 i의 값은 증가된 것이다.

		이런 결과가 나오는 원인은 변수 ++ 연산자의 위치 때문이다. 즉 i++ 와 같이 ++ 연산자가 변수명 뒤에 붙으면 해당 코드가 실행되는 순간에는 i 값이 변경되지 않는다. 다만 i++ 문장이 실행된 이후에 i값이 증가하게 된다. 이와는 반대로 i++ 대신 ++i라고 사용하게 되면 i 값이 먼저 증가된 후에 해당 코드가 실행된다.

		즉, 다음과 같은 차이가 있으니 잊지 말도록 하자.

		i++ : 값이 참조된 후에 증가
		++i : 값이 참조되기 전에 증가
		다음처럼 연산자의 위치를 변경하여 확인 해 보자.

		int i = 0;
		System.out.println(++i);  // 1 출력
		System.out.println(i);  // 1 출력
		++i 에 의해서 i값이 참조되기 전에 증가된 것을 확인 할 수 있다.

		-- 연산자도 ++ 연산자와 동일한 규칙을 따른다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-22 08:12:27.822
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-22 08:12:27.823
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui.ide 4 4 2022-04-22 08:51:45.984
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:275)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:290)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:268)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListFilteredTree.createAdditionalControls(TaskListFilteredTree.java:619)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.createFilterControls(AbstractFilteredTree.java:189)
	at org.eclipse.ui.dialogs.FilteredTree.createControl(FilteredTree.java:362)
	at org.eclipse.mylyn.commons.workbench.EnhancedFilteredTree.createControl(EnhancedFilteredTree.java:61)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.createControl(AbstractFilteredTree.java:91)
	at org.eclipse.ui.dialogs.FilteredTree.init(FilteredTree.java:331)
	at org.eclipse.ui.dialogs.FilteredTree.<init>(FilteredTree.java:289)
	at org.eclipse.mylyn.commons.workbench.EnhancedFilteredTree.<init>(EnhancedFilteredTree.java:48)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.<init>(AbstractFilteredTree.java:71)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListFilteredTree.<init>(TaskListFilteredTree.java:134)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListView.createPartControl(TaskListView.java:590)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:543)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1209)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:676)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:676)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1082)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-04-22 12:02:48.113 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=11.0.14.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-04-22 12:02:57.016
!MESSAGE Warnings while parsing the commands from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.actionDefinitions' extension points.
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-22 12:02:57.016
!MESSAGE Commands should really have a category: plug-in='org.springframework.ide.eclipse.boot', id='org.springframework.ide.eclipse.boot.ui.EnableDisableBootDevtools', categoryId='org.springframework.ide.eclipse.boot.commands.category'

!ENTRY org.eclipse.ui 2 0 2022-04-22 12:02:58.325
!MESSAGE Warnings while parsing the commands from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.actionDefinitions' extension points.
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-22 12:02:58.325
!MESSAGE Commands should really have a category: plug-in='org.springframework.ide.eclipse.boot', id='org.springframework.ide.eclipse.boot.ui.EnableDisableBootDevtools', categoryId='org.springframework.ide.eclipse.boot.commands.category'

!ENTRY org.eclipse.jface 2 0 2022-04-22 12:02:59.203
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-22 12:02:59.203
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3b2317b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56c26b21,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-22 12:02:59.203
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3a72517e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@77a14911,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-04-22 12:03:05.953
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-04-22 12:03:05.962
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-04-22 12:03:06.020
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\lee su min'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.p2.transport.ecf 2 0 2022-04-22 19:24:17.712
!MESSAGE Connection to https://dist.springsource.com/release/STS/doc/updates.xml failed on 알려진 호스트가 없습니다 (dist.springsource.com). Retry attempt 0 started
!STACK 0
java.net.UnknownHostException: 알려진 호스트가 없습니다 (dist.springsource.com)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:929)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1519)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:848)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1509)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1368)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1302)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:376)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1003)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:995)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:991)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.p2.transport.ecf 2 0 2022-04-24 13:04:48.900
!MESSAGE Connection to https://spring.io/blog.atom failed on 알려진 호스트가 없습니다 (spring.io). Retry attempt 0 started
!STACK 0
java.net.UnknownHostException: 알려진 호스트가 없습니다 (spring.io)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:929)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1519)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:848)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1509)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1368)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1302)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:376)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1003)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:995)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:991)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.p2.transport.ecf 2 0 2022-04-24 13:04:48.909
!MESSAGE Connection to https://dist.springsource.com/release/STS/doc/updates.xml failed on 알려진 호스트가 없습니다 (dist.springsource.com). Retry attempt 0 started
!STACK 0
java.net.UnknownHostException: 알려진 호스트가 없습니다 (dist.springsource.com)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:929)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1519)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:848)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1509)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1368)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1302)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:376)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1003)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:995)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:991)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-04-25 09:52:33.426 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=11.0.14.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-04-25 09:52:40.304
!MESSAGE Warnings while parsing the commands from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.actionDefinitions' extension points.
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-25 09:52:40.304
!MESSAGE Commands should really have a category: plug-in='org.springframework.ide.eclipse.boot', id='org.springframework.ide.eclipse.boot.ui.EnableDisableBootDevtools', categoryId='org.springframework.ide.eclipse.boot.commands.category'

!ENTRY org.eclipse.ui 2 0 2022-04-25 09:52:42.789
!MESSAGE Warnings while parsing the commands from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.actionDefinitions' extension points.
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-25 09:52:42.789
!MESSAGE Commands should really have a category: plug-in='org.springframework.ide.eclipse.boot', id='org.springframework.ide.eclipse.boot.ui.EnableDisableBootDevtools', categoryId='org.springframework.ide.eclipse.boot.commands.category'

!ENTRY org.eclipse.jface 2 0 2022-04-25 09:52:43.947
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-25 09:52:43.947
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7fd7965b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9742012,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-25 09:52:43.947
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@118d7e0e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@39ff4421,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-04-25 09:52:50.415
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-04-25 09:52:50.415
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-04-25 09:52:50.478
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\lee su min'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2022-04-25 09:54:03.408
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4907)
	at org.eclipse.swt.SWT.error(SWT.java:4822)
	at org.eclipse.swt.SWT.error(SWT.java:4793)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:445)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:364)
	at org.eclipse.swt.widgets.Control.setEnabled(Control.java:3411)
	at org.eclipse.jst.server.tomcat.ui.internal.TomcatRuntimeComposite.setRuntime(TomcatRuntimeComposite.java:118)
	at org.eclipse.jst.server.tomcat.ui.internal.TomcatRuntimeWizardFragment.enter(TomcatRuntimeWizardFragment.java:58)
	at org.eclipse.wst.server.ui.internal.wizard.TaskWizard$2$1.run(TaskWizard.java:175)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1033)
	at org.eclipse.wst.server.ui.internal.wizard.TaskWizard.performFinish(TaskWizard.java:225)
	at org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:832)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:472)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.wst.server.ui.internal.RuntimePreferencePage.showWizard(RuntimePreferencePage.java:398)
	at org.eclipse.wst.server.ui.internal.RuntimePreferencePage$2.widgetSelected(RuntimePreferencePage.java:148)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.OpenPreferencesAction.run(OpenPreferencesAction.java:66)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-04-25 12:09:24.298 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=11.0.14.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-04-25 12:09:33.897
!MESSAGE Warnings while parsing the commands from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.actionDefinitions' extension points.
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-25 12:09:33.897
!MESSAGE Commands should really have a category: plug-in='org.springframework.ide.eclipse.boot', id='org.springframework.ide.eclipse.boot.ui.EnableDisableBootDevtools', categoryId='org.springframework.ide.eclipse.boot.commands.category'

!ENTRY org.eclipse.ui 2 0 2022-04-25 12:09:35.632
!MESSAGE Warnings while parsing the commands from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.actionDefinitions' extension points.
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-25 12:09:35.632
!MESSAGE Commands should really have a category: plug-in='org.springframework.ide.eclipse.boot', id='org.springframework.ide.eclipse.boot.ui.EnableDisableBootDevtools', categoryId='org.springframework.ide.eclipse.boot.commands.category'

!ENTRY org.eclipse.jface 2 0 2022-04-25 12:09:36.809
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-25 12:09:36.809
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6cf34b88,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5e7fc012,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-25 12:09:36.809
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@63e0c744,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@445d4517,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-04-25 12:09:44.246
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-04-25 12:09:44.246
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-04-25 12:09:44.309
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\lee su min'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-04-25 12:44:11.570
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day3;

public class Sample2 {

	public static void main(String[] args) {
		//04-05 for each문 
		//for each는 J2SE 5.0부터 추가되엇따. for each라는 키워드가 따로 있는것은
		// 아니고 동일한 for를 이용한다. 하지만 조건식부분의 문법이 조금 다르다.
		//다음은 이전에 공부했던 평범한 for문이다.
		String[] numbers = {"one", "tow", "three"};
		for(int i=0; i<numbers.length; i++) {
			System.out.println(numbers[i]);
		}
		//위 for문은 다음처럼 for each구조로 변경할 수 있따.
		String[] numbers2 = {"one", "two", "three"};
		for(String number : numbers2) {
			System.out.println(number);
		}
		//for each문은 보기에 매우 직관적이다.
		//for each문의 구조는 다음과 같다.
		for (type var:iterate) {
			body-of
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-25 12:44:11.613
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-25 12:44:11.615
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-25 12:44:11.626
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day3;

public class Sample2 {

	public static void main(String[] args) {
		//04-05 for each문 
		//for each는 J2SE 5.0부터 추가되엇따. for each라는 키워드가 따로 있는것은
		// 아니고 동일한 for를 이용한다. 하지만 조건식부분의 문법이 조금 다르다.
		//다음은 이전에 공부했던 평범한 for문이다.
		String[] numbers = {"one", "tow", "three"};
		for(int i=0; i<numbers.length; i++) {
			System.out.println(numbers[i]);
		}
		//위 for문은 다음처럼 for each구조로 변경할 수 있따.
		String[] numbers2 = {"one", "two", "three"};
		for(String number : numbers2) {
			System.out.println(number);
		}
		//for each문은 보기에 매우 직관적이다.
		//for each문의 구조는 다음과 같다.
		for (type var:iterate) {
			body-of
		}
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-25 12:44:11.630
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-25 12:44:11.633
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui.ide 4 4 2022-04-25 13:53:07.531
!MESSAGE Not properly disposed SWT resource
!STACK 0
java.lang.Error: SWT Resource was not properly disposed
	at org.eclipse.swt.graphics.Resource.initNonDisposeTracking(Resource.java:172)
	at org.eclipse.swt.graphics.Resource.<init>(Resource.java:120)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:683)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:275)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:290)
	at org.eclipse.jface.resource.ImageDescriptor.createImage(ImageDescriptor.java:268)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListFilteredTree.createAdditionalControls(TaskListFilteredTree.java:619)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.createFilterControls(AbstractFilteredTree.java:189)
	at org.eclipse.ui.dialogs.FilteredTree.createControl(FilteredTree.java:362)
	at org.eclipse.mylyn.commons.workbench.EnhancedFilteredTree.createControl(EnhancedFilteredTree.java:61)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.createControl(AbstractFilteredTree.java:91)
	at org.eclipse.ui.dialogs.FilteredTree.init(FilteredTree.java:331)
	at org.eclipse.ui.dialogs.FilteredTree.<init>(FilteredTree.java:289)
	at org.eclipse.mylyn.commons.workbench.EnhancedFilteredTree.<init>(EnhancedFilteredTree.java:48)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.<init>(AbstractFilteredTree.java:71)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListFilteredTree.<init>(TaskListFilteredTree.java:134)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListView.createPartControl(TaskListView.java:590)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:543)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:994)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1209)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:676)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:116)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.postProcess(PerspectiveStackRenderer.java:64)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:676)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:72)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.processContents(WBWRenderer.java:658)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:672)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:762)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:727)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:711)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1082)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2022-04-26 20:00:09.992 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=11.0.14.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2022-04-26 20:00:17.806
!MESSAGE Warnings while parsing the commands from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.actionDefinitions' extension points.
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-26 20:00:17.806
!MESSAGE Commands should really have a category: plug-in='org.springframework.ide.eclipse.boot', id='org.springframework.ide.eclipse.boot.ui.EnableDisableBootDevtools', categoryId='org.springframework.ide.eclipse.boot.commands.category'

!ENTRY org.eclipse.ui 2 0 2022-04-26 20:00:19.181
!MESSAGE Warnings while parsing the commands from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.actionDefinitions' extension points.
!SUBENTRY 1 org.eclipse.ui 2 0 2022-04-26 20:00:19.181
!MESSAGE Commands should really have a category: plug-in='org.springframework.ide.eclipse.boot', id='org.springframework.ide.eclipse.boot.ui.EnableDisableBootDevtools', categoryId='org.springframework.ide.eclipse.boot.commands.category'

!ENTRY org.eclipse.jface 2 0 2022-04-26 20:00:20.108
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-26 20:00:20.108
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2552cb80,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1b3b5252,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-04-26 20:00:20.108
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@adb15df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f45be42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui.navigator 2 0 2022-04-26 20:00:27.032
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.ui.navigator 2 0 2022-04-26 20:00:27.048
!MESSAGE Can't find Navigator Content Descriptor with id: org.eclipse.jst.servlet.ui.EnhancedJavaRendering

!ENTRY org.eclipse.egit.ui 2 0 2022-04-26 20:00:27.095
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\lee su min'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:25.920
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.

		각각의 연산자는 다음처럼 동작한다.

		x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		x && y - x와 y 모두 참이어야 참이다
		!x - x가 거짓이면 참이다
		이번에는 다음과 같은 상황을 코딩해 보자.

		"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-26 20:16:25.920
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-26 20:16:25.920
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:26.936
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		각각의 연산자는 다음처럼 동작한다.

		x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		x && y - x와 y 모두 참이어야 참이다
		!x - x가 거짓이면 참이다
		이번에는 다음과 같은 상황을 코딩해 보자.

		"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-26 20:16:26.936
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-26 20:16:26.936
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:26.951
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		각각의 연산자는 다음처럼 동작한다.

		x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		x && y - x와 y 모두 참이어야 참이다
		!x - x가 거짓이면 참이다
		이번에는 다음과 같은 상황을 코딩해 보자.

		"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-26 20:16:26.951
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-26 20:16:26.951
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:28.969
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.

		x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		x && y - x와 y 모두 참이어야 참이다
		!x - x가 거짓이면 참이다
		이번에는 다음과 같은 상황을 코딩해 보자.

		"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-26 20:16:28.969
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-26 20:16:28.969
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:30.032
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		x && y - x와 y 모두 참이어야 참이다
		!x - x가 거짓이면 참이다
		이번에는 다음과 같은 상황을 코딩해 보자.

		"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-26 20:16:30.032
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-26 20:16:30.032
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:30.047
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		x && y - x와 y 모두 참이어야 참이다
		!x - x가 거짓이면 참이다
		이번에는 다음과 같은 상황을 코딩해 보자.

		"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-26 20:16:30.047
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-26 20:16:30.047
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:35.536
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		//x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		//x && y - x와 y 모두 참이어야 참이다
		//!x - x가 거짓이면 참이다
		//이번에는 다음과 같은 상황을 코딩해 보자.

		//"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-26 20:16:35.552
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-26 20:16:35.552
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:36.552
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		//x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		//x && y - x와 y 모두 참이어야 참이다
		//!x - x가 거짓이면 참이다
		//이번에는 다음과 같은 상황을 코딩해 보자.
		//"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-26 20:16:36.552
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-26 20:16:36.568
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:36.583
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		//x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		//x && y - x와 y 모두 참이어야 참이다
		//!x - x가 거짓이면 참이다
		//이번에는 다음과 같은 상황을 코딩해 보자.
		//"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-26 20:16:36.583
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-26 20:16:36.583
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:38.069
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		//x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		//x && y - x와 y 모두 참이어야 참이다
		//!x - x가 거짓이면 참이다\
		
		//이번에는 다음과 같은 상황을 코딩해 보자.
		//"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-26 20:16:38.085
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-26 20:16:38.085
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:38.101
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		//x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		//x && y - x와 y 모두 참이어야 참이다
		//!x - x가 거짓이면 참이다\
		
		//이번에는 다음과 같은 상황을 코딩해 보자.
		//"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"

		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-26 20:16:38.101
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-26 20:16:38.101
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:39.585
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		//x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		//x && y - x와 y 모두 참이어야 참이다
		//!x - x가 거짓이면 참이다\
		
		//이번에는 다음과 같은 상황을 코딩해 보자.
		//"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"
		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-04-26 20:16:39.601
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-04-26 20:16:39.601
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:39.616
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		//x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		//x && y - x와 y 모두 참이어야 참이다
		//!x - x가 거짓이면 참이다\
		
		//이번에는 다음과 같은 상황을 코딩해 보자.
		//"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"
		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-26 20:16:39.616
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-26 20:16:39.616
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:40.664
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		//x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		//x && y - x와 y 모두 참이어야 참이다
		//!x - x가 거짓이면 참이다\
		
		//이번에는 다음과 같은 상황을 코딩해 보자.
		//"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"
		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-26 20:16:40.679
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-26 20:16:40.679
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:42.680
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		//x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		//x && y - x와 y 모두 참이어야 참이다
		//!x - x가 거짓이면 참이다\
		
		//이번에는 다음과 같은 상황을 코딩해 보자.
		//"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"
		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-26 20:16:42.696
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-26 20:16:42.696
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-04-26 20:16:43.384
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package day2;

public class Sample4 {

	public static void main(String[] args) {
		// 04-01 if 문
		//다음과 같은 상상을 해 보자.

		//"돈이 있으면 택시를 타고 가고 돈이 없으면 걸어 간다."
		//위와 같은 상황은 우리 주변에서 언제든지 일어 날 수 있는 상황중의 하나이다. 
		//프로그래밍도 위처럼 조건을 판단해서 그 상황에 맞게 처리해야 할 경우가 생기게 된다. 
		//이렇듯 조건을 판단하여 해당 조건에 맞는 상황을 수행하는데 쓰이는 것이 바로 if문이다.
		//위 상황을 자바는 다음과 같이 만들 수 있다.

		//boolean money = true;
		//if (money) {
		   //System.out.println("택시를 타고 가라");
		//}else {
		   //System.out.println("걸어가라");
		//}
		//if문의 기본 구조
		//조건문이란 무엇인가?
		//비교연산자
		//and(&&), or(||), not(!)
		//contains
		//else if (다중 조건 판단)
		//if문의 기본 구조
		//다음의 구조가 if와 else를 사용하는 기본 구조이다.

		//if (조건문) {
		    //<수행할 문장1>;
		    //<수행할 문장2>;
		    //...
		//} else {
		    //<수행할 문장A>;
		    //<수행할 문장B>;
		    //...
		//}
		//조건문을 테스트 해서 참이면 if문에 속한 문장들을 수행하고 조건문이 거짓이면 else문에 속한 문장들을 수행한다.
		
		
		//조건문이란 무엇인가?
		//if (조건문)에 사용한 조건문은 참과 거짓을 판단하는 문장이다.
		//즉, 위의 예에서 보았던 money가 조건문이 된다.
		//boolean money = true;
		//if (money) {
		//...
		//money는 true이기 때문에 if문에 속한 문장들이 수행된다.

		//비교연산자
		//이번에는 조건판단에 사용되는 비교 연산자(<, >, ==, !=, >=, <=)에 대해서 알아보자.
		//다음은 자바의 비교 연산자들이다.

		//비교연산자	설명
		//x < y	x가 y보다 작다
		//x > y	x가 y보다 크다
		//x == y	x와 y가 같다
		//x != y	x와 y가 같지 않다
		//x >= y	x가 y보다 크거나 같다
		//x <= y	x가 y보다 작거나 같다
		//예를 통해서 연산자들에 대해서 알아보자.
		//int x = 3;
		//int y = 2;
		//System.out.println(x > y); //true 출력
		//x에 3, y에 2를 대입한 다음에 x > y 라는 조건문을 출력하니 true가 출력된다. 왜냐하면 x > y 조건문이 참이기 때문이다.
		//System.out.println(x < y); //false  출력
		//위 조건문은 거짓이기 때문에 false가 출력된다.
		//System.out.println(x == y); //false 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 거짓이다.
		//System.out.println(x != y); //true 출력
		//x와 y는 같지 않다. 따라서 위의 조건문은 참이다.

		//앞의 택시예제를 다음처럼 바꾸어 보자.
		//"만약 3000원 이상의 돈을 가지고 있으면 택시를 타고 그렇지 않으면 걸어가라"
		//위 상황은 다음처럼 코딩할 수 있다.
		//int money = 2000;
		//if (money >= 3000) {
		    //System.out.println("택시를 타고 가라");
		//}else {
		    //System.out.println("걸어가라");
		//}
		//money >= 3000 이란 조건문이 거짓이 되기 때문에 else문의 문장이 수행되어 "걸어가라"가 출력된다.
		//and(&&), or(||), not(!)
		//이외에도 조건 판단에 쓰이는 and, or, not 연산자가 있다.
		//각각의 연산자는 다음처럼 동작한다.
		//x || y - x와 y 둘 중 적어도 하나가 참이면 참이다
		//x && y - x와 y 모두 참이어야 참이다
		//!x - x가 거짓이면 참이다\
		
		//이번에는 다음과 같은 상황을 코딩해 보자.
		//"돈이 3000원 이상 있거나 카드가 있다면 택시를 타고 그렇지 않으면 걸어가라"
		int money = 2000;
		boolean hasCard = true;

		if (money>=3000 || hasCard) {
		    System.out.println("택시를 타고 가라");
		} else {
		    System.out.println("걸어가라");
		}
		money는 2000으로 3000보다 작지만 hasCard가 true이기 때문에 money >= 3000 || hasCard 조건문이 참이 되어 "택시를 타고 가라"가 출력된다.

		contains
		List 자료형에는 해당 아이템이 있는지 조사하는 contains 메소드가 있다. contains 메소드는 조건문에 많이 활용되는데 어떻게 활용이 되는지 살펴보자.

		이번에는 다음의 상황을 코딩해 보자.

		"만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라“

		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");
		pocket.add("money");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    System.out.println("걸어가라");
		}
		pocket 리스트에 안에 'money'가 있으므로 pocket.contains("money")가 참이 되어 "택시를 타고 가라"가 출력된다.

		else if (다중 조건 판단)
		if와 else만으로는 다양한 조건 판단을 하기가 어렵다. 다음과 같은 예만 하더라도 if와 else만으로는 조건 판단에 어려움을 겪게 된다.

		"지갑에 돈이 있으면 택시를 타고, 지갑엔 돈이 없지만 카드가 있으면 택시를 타고, 돈도 없고 카드도 없으면 걸어가라“

		위의 문장을 보면 조건을 판단하는 부분이 두 군데가 있다. 먼저 지갑에 돈이 있는지를 판단해야 하고 지갑에 돈이 없으면 다시 카드가 있는지를 판단한다.

		if와 else만으로 위의 문장을 표현 하려면 다음과 같이 해야한다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else {
		    if (hasCard) {
		        System.out.println("택시를 타고 가라");
		    }else {         
		        System.out.println("걸어가라");
		    }
		}
		if와 else가 여러번 사용되어 이해하기가 쉽지 않고 산만한 느낌이 든다. 위와 같은 점을 보완하기 위해서 자바는 다중 조건 판단을 가능하게 하는 else if가 있다.

		다음은 위 예에 else if를 적용한 코드이다.

		boolean hasCard = true;
		ArrayList<String> pocket = new ArrayList<String>();
		pocket.add("paper");
		pocket.add("handphone");

		if (pocket.contains("money")) {
		    System.out.println("택시를 타고 가라");
		}else if(hasCard) {
		    System.out.println("택시를 타고 가라");
		}else {         
		    System.out.println("걸어가라");
		}
		else if는 이전 조건문이 거짓일 때 수행된다. 따라서 위 예에서 pocket.contains("money") 문장이 거짓이므로 else if 문이 수행되고 hasCard가 true이므로 "택시를 타고 가라"가 출력된다.

		if, else if, else의 기본 구조는 다음과 같다.

		if (조건문) {
		    <수행할 문장1> 
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		}else if (조건문) {
		    <수행할 문장1>
		    <수행할 문장2>
		    ...
		...
		} else {
		   <수행할 문장1>
		   <수행할 문장2>
		   ... 
		}
		else if는 개수에 제한 없이 사용할 수 있다.

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-04-26 20:16:43.399
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-04-26 20:16:43.399
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2693)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2041)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
